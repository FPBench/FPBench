;; -*- mode: scheme -*-

(FPCore
 (sr* sl*)
 :name
 "Odometry"
 :description
 "Compute the position of a robot from the speed of the wheels.\nInputs: Speed `sl`, `sr` of the left and right wheel, in rad/s."
 :cite
 (damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 controls
 :precision
 binary32
 :pre
 (and (< 0.05 sl* (* 2 PI)) (< 0.05 sr* (* 2 PI)))
 :example
 ((sr* 0.0785398163397) (sl* 0.0525398163397))
 (while
  (< t 1000)
  ((x
    0.0
    (let ((cosi
           (let ((arg
                  (let ((delta_theta
                         (let ((inv_l 0.1)
                               (delta_dl (let ((c 12.34)) (* c sl)))
                               (delta_dr (let ((c 12.34)) (* c sr))))
                           (* (- delta_dr delta_dl) inv_l))))
                    (+ theta (* delta_theta 0.5)))))
             (+
              (- 1 (* (* arg arg) 0.5))
              (* (* (* (* arg arg) arg) arg) 0.0416666666))))
          (delta_d
           (let ((delta_dr (let ((c 12.34)) (* c sr)))
                 (delta_dl (let ((c 12.34)) (* c sl))))
             (* (+ delta_dl delta_dr) 0.5))))
      (+ x (* delta_d cosi))))
   (y
    0.0
    (let ((sini
           (let ((arg
                  (let ((delta_theta
                         (let ((inv_l 0.1)
                               (delta_dl (let ((c 12.34)) (* c sl)))
                               (delta_dr (let ((c 12.34)) (* c sr))))
                           (* (- delta_dr delta_dl) inv_l))))
                    (+ theta (* delta_theta 0.5)))))
             (+
              (- arg (* (* (* arg arg) arg) 0.1666666666))
              (* (* (* (* (* arg arg) arg) arg) arg) 0.008333333))))
          (delta_d
           (let ((delta_dr (let ((c 12.34)) (* c sr)))
                 (delta_dl (let ((c 12.34)) (* c sl))))
             (* (+ delta_dl delta_dr) 0.5))))
      (+ y (* delta_d sini))))
   (theta
    -0.985
    (let ((delta_theta
           (let ((inv_l 0.1)
                 (delta_dl (let ((c 12.34)) (* c sl)))
                 (delta_dr (let ((c 12.34)) (* c sr))))
             (* (- delta_dr delta_dl) inv_l))))
      (+ theta delta_theta)))
   (t 0 (+ t 1))
   (j 0 (if (== j 50) 0 (+ j 1)))
   (tmp 0.0 (if (== j 50) sl tmp))
   (sl sl* (if (== j 50) sr sl))
   (sr sr* (if (== j 50) (let ((tmp sl)) tmp) sr)))
  x))

(FPCore
 (sr* sl*)
 :name
 "Odometry"
 :description
 "Compute the position of a robot from the speed of the wheels.\nInputs: Speed `sl`, `sr` of the left and right wheel, in rad/s."
 :cite
 (damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 controls
 :precision
 binary32
 :pre
 (and (< 0.05 sl* (* 2 PI)) (< 0.05 sr* (* 2 PI)))
 :example
 ((sr* 0.0785398163397) (sl* 0.0525398163397))
 (while
  (< t 1000)
  ((x
    0.0
    (let ((cosi
           (let ((arg
                  (let ((delta_theta
                         (let ((inv_l 0.1)
                               (delta_dl (let ((c 12.34)) (* c sl)))
                               (delta_dr (let ((c 12.34)) (* c sr))))
                           (* (- delta_dr delta_dl) inv_l))))
                    (+ theta (* delta_theta 0.5)))))
             (+
              (- 1 (* (* arg arg) 0.5))
              (* (* (* (* arg arg) arg) arg) 0.0416666666))))
          (delta_d
           (let ((delta_dr (let ((c 12.34)) (* c sr)))
                 (delta_dl (let ((c 12.34)) (* c sl))))
             (* (+ delta_dl delta_dr) 0.5))))
      (+ x (* delta_d cosi))))
   (y
    0.0
    (let ((sini
           (let ((arg
                  (let ((delta_theta
                         (let ((inv_l 0.1)
                               (delta_dl (let ((c 12.34)) (* c sl)))
                               (delta_dr (let ((c 12.34)) (* c sr))))
                           (* (- delta_dr delta_dl) inv_l))))
                    (+ theta (* delta_theta 0.5)))))
             (+
              (- arg (* (* (* arg arg) arg) 0.1666666666))
              (* (* (* (* (* arg arg) arg) arg) arg) 0.008333333))))
          (delta_d
           (let ((delta_dr (let ((c 12.34)) (* c sr)))
                 (delta_dl (let ((c 12.34)) (* c sl))))
             (* (+ delta_dl delta_dr) 0.5))))
      (+ y (* delta_d sini))))
   (theta
    -0.985
    (let ((delta_theta
           (let ((inv_l 0.1)
                 (delta_dl (let ((c 12.34)) (* c sl)))
                 (delta_dr (let ((c 12.34)) (* c sr))))
             (* (- delta_dr delta_dl) inv_l))))
      (+ theta delta_theta)))
   (t 0 (+ t 1))
   (j 0 (if (== j 50) 0 (+ j 1)))
   (tmp 0.0 (if (== j 50) sl tmp))
   (sl sl* (if (== j 50) sr sl))
   (sr sr* (if (== j 50) (let ((tmp sl)) tmp) sr)))
  y))

(FPCore
 (m kp ki kd c)
 :name
 "PID"
 :description
 "Keep a measure at its setpoint using a PID controller.\nInputs: Measure `m`; gains `kp`, `ki`, `kd`; setpoint `c`"
 :cite
 (damouche-martel-chapoutot-nsv14 damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 controls
 :precision
 binary64
 :pre
 (and (< -10.0 m 10.0) (< -10.0 c 10.0))
 :example
 ((m -5.0) (kp 9.4514) (ki 0.69006) (kd 2.8454))
 (while
  (< t 100.0)
  ((i 0.0 (let ((e (- c m)) (dt 0.2)) (+ i (* (* ki dt) e))))
   (m
    m
    (let ((r
           (let ((d
                  (let ((e (- c m)) (invdt (let ((dt 0.2)) (/ 1 dt))))
                    (* (* kd invdt) (- e eold))))
                 (i (let ((e (- c m)) (dt 0.2)) (+ i (* (* ki dt) e))))
                 (p (let ((e (- c m))) (* kp e))))
             (+ (+ p i) d))))
      (+ m (* 0.01 r))))
   (eold 0.0 (let ((e (- c m))) e))
   (t 0.0 (let ((dt 0.2)) (+ t dt))))
  m))

(FPCore
 (h y_n* c)
 :name
 "Runge-Kutta 4"
 :description
 "Solve the differential equation `y' = (c - y)^2\nInputs: Step size `h`; initial condition `y_n*`; paramter `c`"
 :cite
 (damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 0 y_n* 100) (< 1e-05 h 0.1) (< 50 c 200))
 :example
 ((h 0.1) (y_n* 10.1) (c 100.1))
 (while
  (let ((eps 0.005)) (> e eps))
  ((t 0.0 (+ t 0.1))
   (i 0.0 (+ i 1.0))
   (y_n
    y_n*
    (let ((y_n1
           (let ((k4
                  (let ((k3
                         (let ((k2
                                (let ((k1
                                       (let ((k 1.2))
                                         (* (* k (- c y_n)) (- c y_n))))
                                      (k 1.2))
                                  (*
                                   (* k (- c (+ y_n (* (* 0.5 h) k1))))
                                   (- c (+ y_n (* (* 0.5 h) k1))))))
                               (k 1.2))
                           (*
                            (* k (- c (+ y_n (* (* 0.5 h) k2))))
                            (- c (+ y_n (* (* 0.5 h) k2))))))
                        (k 1.2))
                    (* (* k (- c (+ y_n (* h k3)))) (- c (+ y_n (* h k3))))))
                 (k3
                  (let ((k2
                         (let ((k1
                                (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                               (k 1.2))
                           (*
                            (* k (- c (+ y_n (* (* 0.5 h) k1))))
                            (- c (+ y_n (* (* 0.5 h) k1))))))
                        (k 1.2))
                    (*
                     (* k (- c (+ y_n (* (* 0.5 h) k2))))
                     (- c (+ y_n (* (* 0.5 h) k2))))))
                 (k2
                  (let ((k1 (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                        (k 1.2))
                    (*
                     (* k (- c (+ y_n (* (* 0.5 h) k1))))
                     (- c (+ y_n (* (* 0.5 h) k1))))))
                 (k1 (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                 (sixieme (/ 1 6)))
             (+
              y_n
              (* (* sixieme h) (+ (+ (+ k1 (* 2.0 k2)) (* 2.0 k3)) k4))))))
      y_n1))
   (e 1.0 (let ((eps 0.005)) (- e eps))))
  i))

(FPCore
 (h y_n* c)
 :name
 "Runge-Kutta 4"
 :description
 "Solve the differential equation `y' = (c - y)^2\nInputs: Step size `h`; initial condition `y_n*`; paramter `c`"
 :cite
 (damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 0 y_n* 100) (< 1e-05 h 0.1) (< 50 c 200))
 :example
 ((h 0.1) (y_n* 10.1) (c 100.1))
 (while
  (let ((eps 0.005)) (> e eps))
  ((t 0.0 (+ t 0.1))
   (i 0.0 (+ i 1.0))
   (y_n
    y_n*
    (let ((y_n1
           (let ((k4
                  (let ((k3
                         (let ((k2
                                (let ((k1
                                       (let ((k 1.2))
                                         (* (* k (- c y_n)) (- c y_n))))
                                      (k 1.2))
                                  (*
                                   (* k (- c (+ y_n (* (* 0.5 h) k1))))
                                   (- c (+ y_n (* (* 0.5 h) k1))))))
                               (k 1.2))
                           (*
                            (* k (- c (+ y_n (* (* 0.5 h) k2))))
                            (- c (+ y_n (* (* 0.5 h) k2))))))
                        (k 1.2))
                    (* (* k (- c (+ y_n (* h k3)))) (- c (+ y_n (* h k3))))))
                 (k3
                  (let ((k2
                         (let ((k1
                                (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                               (k 1.2))
                           (*
                            (* k (- c (+ y_n (* (* 0.5 h) k1))))
                            (- c (+ y_n (* (* 0.5 h) k1))))))
                        (k 1.2))
                    (*
                     (* k (- c (+ y_n (* (* 0.5 h) k2))))
                     (- c (+ y_n (* (* 0.5 h) k2))))))
                 (k2
                  (let ((k1 (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                        (k 1.2))
                    (*
                     (* k (- c (+ y_n (* (* 0.5 h) k1))))
                     (- c (+ y_n (* (* 0.5 h) k1))))))
                 (k1 (let ((k 1.2)) (* (* k (- c y_n)) (- c y_n))))
                 (sixieme (/ 1 6)))
             (+
              y_n
              (* (* sixieme h) (+ (+ (+ k1 (* 2.0 k2)) (* 2.0 k3)) k4))))))
      y_n1))
   (e 1.0 (let ((eps 0.005)) (- e eps))))
  (let ((e (fabs e))) e)))

(FPCore
 (y yd)
 :name
 "Lead-lag System"
 :description
 "Move a mass from an initial position to a desired position.\nInputs: Initial position `y`; desired position `yd`"
 :cite
 (feron-ieee10 damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 controls
 :precision
 binary32
 :pre
 (and (< 0 yd 50) (< 0 y 50))
 :example
 ((y 2.5) (yd 5.0))
 (while
  (let ((eps 0.01)) (> e eps))
  ((xc0
    0.0
    (let ((yc
           (let ((yc (let ((yc (- y yd))) (if (< yc -1.0) -1.0 yc))))
             (if (< 1.0 yc) 1.0 yc)))
          (Bc0 1.0)
          (Ac01 -0.05)
          (Ac00 0.499))
      (+ (* Ac00 xc0) (+ (* Ac01 xc1) (* Bc0 yc)))))
   (xc1
    0.0
    (let ((yc
           (let ((yc (let ((yc (- y yd))) (if (< yc -1.0) -1.0 yc))))
             (if (< 1.0 yc) 1.0 yc)))
          (Bc1 0.0)
          (Ac11 1.0)
          (xc0
           (let ((yc
                  (let ((yc (let ((yc (- y yd))) (if (< yc -1.0) -1.0 yc))))
                    (if (< 1.0 yc) 1.0 yc)))
                 (Bc0 1.0)
                 (Ac01 -0.05)
                 (Ac00 0.499))
             (+ (* Ac00 xc0) (+ (* Ac01 xc1) (* Bc0 yc)))))
          (Ac10 0.01))
      (+ (* Ac10 xc0) (+ (* Ac11 xc1) (* Bc1 yc)))))
   (i 0.0 (+ i 1.0))
   (e
    1.0
    (let ((xc1
           (let ((yc
                  (let ((yc (let ((yc (- y yd))) (if (< yc -1.0) -1.0 yc))))
                    (if (< 1.0 yc) 1.0 yc)))
                 (Bc1 0.0)
                 (Ac11 1.0)
                 (xc0
                  (let ((yc
                         (let ((yc
                                (let ((yc (- y yd)))
                                  (if (< yc -1.0) -1.0 yc))))
                           (if (< 1.0 yc) 1.0 yc)))
                        (Bc0 1.0)
                        (Ac01 -0.05)
                        (Ac00 0.499))
                    (+ (* Ac00 xc0) (+ (* Ac01 xc1) (* Bc0 yc)))))
                 (Ac10 0.01))
             (+ (* Ac10 xc0) (+ (* Ac11 xc1) (* Bc1 yc)))))
          (yc
           (let ((yc (let ((yc (- y yd))) (if (< yc -1.0) -1.0 yc))))
             (if (< 1.0 yc) 1.0 yc))))
      (fabs (- yc xc1)))))
  xc1))

(FPCore
 (u)
 :name
 "Trapeze"
 :cite
 (damouche-martel-chapoutot-fmics15)
 :fpbench-domain
 mathematics
 :pre
 (<= 1.11 u 2.22)
 (while
  (< xa 5000)
  ((r
    0
    (let ((h (let ((n 25) (a 0.25) (b 5000)) (/ (- b a) n)))
          (gxb
           (let ((xb
                  (let ((xb
                         (let ((h
                                (let ((n 25) (a 0.25) (b 5000))
                                  (/ (- b a) n))))
                           (+ xa h))))
                    (if (let ((xb
                               (let ((h
                                      (let ((n 25) (a 0.25) (b 5000))
                                        (/ (- b a) n))))
                                 (+ xa h))))
                          (> xb 5000))
                      5000
                      xb))))
             (/
              u
              (-
               (+ (- (* (* (* 0.7 xb) xb) xb) (* (* 0.6 xb) xb)) (* 0.9 xb))
               0.2))))
          (gxa
           (/
            u
            (-
             (+ (- (* (* (* 0.7 xa) xa) xa) (* (* 0.6 xa) xa)) (* 0.9 xa))
             0.2))))
      (+ r (* (* (+ gxa gxb) 0.5) h))))
   (xa
    0.25
    (let ((h (let ((n 25) (a 0.25) (b 5000)) (/ (- b a) n)))) (+ xa h))))
  r))

(FPCore
 (Mf A)
 :name
 "Rocket Trajectory"
 :description
 "Compute the trajectory of a rocket around the earth.\nInputs: Mass `Mf`; acceleration `A`"
 :cite
 (damouche-martel-chapoutot-cf15)
 :fpbench-domain
 controls
 :precision
 binary32
 :example
 ((Mf 150000.0) (A 140.0))
 (while
  (< i 2000000.0)
  ((x
    0.0
    (let ((c
           (let ((u3_i (let ((dt 0.1)) (+ (* u4_im1 dt) u3_im1)))) (cos u3_i)))
          (u1_i (let ((dt 0.1)) (+ (* u2_im1 dt) u1_im1))))
      (* u1_i c)))
   (i 1.0 (+ i 1.0))
   (u1_im1
    (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))) r0)
    (let ((u1_i (let ((dt 0.1)) (+ (* u2_im1 dt) u1_im1)))) u1_i))
   (u2_im1
    (let ((vr0 0.0)) vr0)
    (let ((u2_i
           (let ((dt 0.1) (Mt 5.9736e+24) (G 6.67428e-11))
             (+
              (* (* G (/ Mt (* u1_im1 u1_im1))) dt)
              (* (* (* u1_im1 u4_im1) u4_im1) dt)))))
      u2_i))
   (u3_im1
    (let ((teta0 0.0)) teta0)
    (let ((u3_i (let ((dt 0.1)) (+ (* u4_im1 dt) u3_im1)))) u3_i))
   (u4_im1
    (let ((vteta0
           (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                 (viss
                  (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                        (Mt 5.9736e+24)
                        (G 6.67428e-11))
                    (sqrt (/ (* G Mt) r0)))))
             (/ viss r0))))
      vteta0)
    (let ((u4_i
           (let ((dt 0.1))
             (+ (* (* -2.0 (* u2_im1 (/ u4_im1 u1_im1))) dt) u4_im1))))
      u4_i))
   (w1_im1
    (let ((rf (let ((R 6400000.0)) R))) rf)
    (let ((w1_i (let ((dt 0.1)) (+ (* w2_im1 dt) w1_im1)))) w1_i))
   (w2_im1
    (let ((vrf 0.0)) vrf)
    (let ((w2_i
           (let ((dt 0.1) (Mt 5.9736e+24) (G 6.67428e-11))
             (+
              (+
               (+
                (* (* G (/ Mt (* w1_im1 w1_im1))) dt)
                (* (* (* w1_im1 w4_im1) w4_im1) dt))
               (if (> mf_im1 0.0)
                 (* (/ (* A w2_im1) (- Mf (* A t_im1))) dt)
                 0.0))
              w2_im1))))
      w2_i))
   (w3_im1
    (let ((tetaf 0.0)) tetaf)
    (let ((w3_i (let ((dt 0.1)) (+ (* w4_im1 dt) w3_im1)))) w3_i))
   (w4_im1
    (let ((vtetaf
           (let ((vlrad
                  (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                        (vl
                         (let ((R 6400000.0) (Mt 5.9736e+24) (G 6.67428e-11))
                           (sqrt (/ (* G Mt) R)))))
                    (/ vl r0))))
             (* 1.1 vlrad))))
      vtetaf)
    (let ((w4_i
           (let ((dt 0.1))
             (+
              (* (* -2.0 (* w2_im1 (/ w4_im1 w1_im1))) dt)
              (+
               (if (> mf_im1 0.0)
                 (* A (* (/ w4_im1 (- Mf (* A t_im1))) dt))
                 0.0)
               w4_im1)))))
      w4_i))
   (t_im1 0.0 (let ((t_i (let ((dt 0.1)) (+ t_im1 dt)))) t_i))
   (mf_im1 Mf (let ((mf_i (- mf_im1 (* A t_im1)))) mf_i)))
  x))

(FPCore
 (Mf A)
 :name
 "Rocket Trajectory"
 :description
 "Compute the trajectory of a rocket around the earth.\nInputs: Mass `Mf`; acceleration `A`"
 :cite
 (damouche-martel-chapoutot-cf15)
 :fpbench-domain
 controls
 :precision
 binary32
 :example
 ((Mf 150000.0) (A 140.0))
 (while
  (< i 2000000.0)
  ((y
    0.0
    (let ((s
           (let ((u3_i (let ((dt 0.1)) (+ (* u4_im1 dt) u3_im1)))) (sin u3_i)))
          (u1_i (let ((dt 0.1)) (+ (* u2_im1 dt) u1_im1))))
      (* u1_i s)))
   (i 1.0 (+ i 1.0))
   (u1_im1
    (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))) r0)
    (let ((u1_i (let ((dt 0.1)) (+ (* u2_im1 dt) u1_im1)))) u1_i))
   (u2_im1
    (let ((vr0 0.0)) vr0)
    (let ((u2_i
           (let ((dt 0.1) (Mt 5.9736e+24) (G 6.67428e-11))
             (+
              (* (* G (/ Mt (* u1_im1 u1_im1))) dt)
              (* (* (* u1_im1 u4_im1) u4_im1) dt)))))
      u2_i))
   (u3_im1
    (let ((teta0 0.0)) teta0)
    (let ((u3_i (let ((dt 0.1)) (+ (* u4_im1 dt) u3_im1)))) u3_i))
   (u4_im1
    (let ((vteta0
           (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                 (viss
                  (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                        (Mt 5.9736e+24)
                        (G 6.67428e-11))
                    (sqrt (/ (* G Mt) r0)))))
             (/ viss r0))))
      vteta0)
    (let ((u4_i
           (let ((dt 0.1))
             (+ (* (* -2.0 (* u2_im1 (/ u4_im1 u1_im1))) dt) u4_im1))))
      u4_i))
   (w1_im1
    (let ((rf (let ((R 6400000.0)) R))) rf)
    (let ((w1_i (let ((dt 0.1)) (+ (* w2_im1 dt) w1_im1)))) w1_i))
   (w2_im1
    (let ((vrf 0.0)) vrf)
    (let ((w2_i
           (let ((dt 0.1) (Mt 5.9736e+24) (G 6.67428e-11))
             (+
              (+
               (+
                (* (* G (/ Mt (* w1_im1 w1_im1))) dt)
                (* (* (* w1_im1 w4_im1) w4_im1) dt))
               (if (> mf_im1 0.0)
                 (* (/ (* A w2_im1) (- Mf (* A t_im1))) dt)
                 0.0))
              w2_im1))))
      w2_i))
   (w3_im1
    (let ((tetaf 0.0)) tetaf)
    (let ((w3_i (let ((dt 0.1)) (+ (* w4_im1 dt) w3_im1)))) w3_i))
   (w4_im1
    (let ((vtetaf
           (let ((vlrad
                  (let ((r0 (let ((R 6400000.0)) (+ (* 400.0 10000.0) R)))
                        (vl
                         (let ((R 6400000.0) (Mt 5.9736e+24) (G 6.67428e-11))
                           (sqrt (/ (* G Mt) R)))))
                    (/ vl r0))))
             (* 1.1 vlrad))))
      vtetaf)
    (let ((w4_i
           (let ((dt 0.1))
             (+
              (* (* -2.0 (* w2_im1 (/ w4_im1 w1_im1))) dt)
              (+
               (if (> mf_im1 0.0)
                 (* A (* (/ w4_im1 (- Mf (* A t_im1))) dt))
                 0.0)
               w4_im1)))))
      w4_i))
   (t_im1 0.0 (let ((t_i (let ((dt 0.1)) (+ t_im1 dt)))) t_i))
   (mf_im1 Mf (let ((mf_i (- mf_im1 (* A t_im1)))) mf_i)))
  y))

(FPCore
 (a11 a22 a33 a44 b1 b2 b3 b4)
 :name
 "Jacobi's Method"
 :description
 "Solve a linear system `Ax = b`.\nInputs: Array entries `aij`; vector entries `bi`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :example
 ((a11 0.61)
  (a22 0.62)
  (a33 0.6006)
  (a44 0.601)
  (b1 0.5)
  (b2 (/ 1.0 3.0))
  (b3 0.25)
  (b4 (/ 1.0 5.0)))
 (while
  (let ((eps 1e-17)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (e
    1.0
    (let ((e
           (let ((x_n4
                  (-
                   (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
                   (* (/ 0.3 a44) x3))))
             (- x_n4 x4))))
      (fabs e)))
   (x1
    0.0
    (let ((x_n1
           (+
            (- (- (/ b1 a11) (* (/ 0.1 a11) x2)) (* (/ 0.2 a11) x3))
            (* (/ 0.3 a11) x4))))
      x_n1))
   (x2
    0.0
    (let ((x_n2
           (-
            (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
            (* (/ 0.2 a22) x4))))
      x_n2))
   (x3
    0.0
    (let ((x_n3
           (-
            (+ (- (/ b3 a33) (* (/ 0.2 a33) x1)) (* (/ 0.3 a33) x2))
            (* (/ 0.1 a33) x4))))
      x_n3))
   (x4
    0.0
    (let ((x_n4
           (-
            (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
            (* (/ 0.3 a44) x3))))
      x_n4)))
  i))

(FPCore
 (a11 a22 a33 a44 b1 b2 b3 b4)
 :name
 "Jacobi's Method"
 :description
 "Solve a linear system `Ax = b`.\nInputs: Array entries `aij`; vector entries `bi`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :example
 ((a11 0.61)
  (a22 0.62)
  (a33 0.6006)
  (a44 0.601)
  (b1 0.5)
  (b2 (/ 1.0 3.0))
  (b3 0.25)
  (b4 (/ 1.0 5.0)))
 (while
  (let ((eps 1e-17)) (> e eps))
  ((x_n2
    0.0
    (-
     (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
     (* (/ 0.2 a22) x4)))
   (i 0.0 (+ i 1.0))
   (e
    1.0
    (let ((e
           (let ((x_n4
                  (-
                   (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
                   (* (/ 0.3 a44) x3))))
             (- x_n4 x4))))
      (fabs e)))
   (x1
    0.0
    (let ((x_n1
           (+
            (- (- (/ b1 a11) (* (/ 0.1 a11) x2)) (* (/ 0.2 a11) x3))
            (* (/ 0.3 a11) x4))))
      x_n1))
   (x2
    0.0
    (let ((x_n2
           (-
            (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
            (* (/ 0.2 a22) x4))))
      x_n2))
   (x3
    0.0
    (let ((x_n3
           (-
            (+ (- (/ b3 a33) (* (/ 0.2 a33) x1)) (* (/ 0.3 a33) x2))
            (* (/ 0.1 a33) x4))))
      x_n3))
   (x4
    0.0
    (let ((x_n4
           (-
            (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
            (* (/ 0.3 a44) x3))))
      x_n4)))
  x_n2))

(FPCore
 (a11 a22 a33 a44 b1 b2 b3 b4)
 :name
 "Jacobi's Method"
 :description
 "Solve a linear system `Ax = b`.\nInputs: Array entries `aij`; vector entries `bi`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :example
 ((a11 0.61)
  (a22 0.62)
  (a33 0.6006)
  (a44 0.601)
  (b1 0.5)
  (b2 (/ 1.0 3.0))
  (b3 0.25)
  (b4 (/ 1.0 5.0)))
 (while
  (let ((eps 1e-17)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (e
    1.0
    (let ((e
           (let ((x_n4
                  (-
                   (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
                   (* (/ 0.3 a44) x3))))
             (- x_n4 x4))))
      (fabs e)))
   (x1
    0.0
    (let ((x_n1
           (+
            (- (- (/ b1 a11) (* (/ 0.1 a11) x2)) (* (/ 0.2 a11) x3))
            (* (/ 0.3 a11) x4))))
      x_n1))
   (x2
    0.0
    (let ((x_n2
           (-
            (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
            (* (/ 0.2 a22) x4))))
      x_n2))
   (x3
    0.0
    (let ((x_n3
           (-
            (+ (- (/ b3 a33) (* (/ 0.2 a33) x1)) (* (/ 0.3 a33) x2))
            (* (/ 0.1 a33) x4))))
      x_n3))
   (x4
    0.0
    (let ((x_n4
           (-
            (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
            (* (/ 0.3 a44) x3))))
      x_n4)))
  x2))

(FPCore
 (a11 a22 a33 a44 b1 b2 b3 b4)
 :name
 "Jacobi's Method"
 :description
 "Solve a linear system `Ax = b`.\nInputs: Array entries `aij`; vector entries `bi`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :example
 ((a11 0.61)
  (a22 0.62)
  (a33 0.6006)
  (a44 0.601)
  (b1 0.5)
  (b2 (/ 1.0 3.0))
  (b3 0.25)
  (b4 (/ 1.0 5.0)))
 (while
  (let ((eps 1e-17)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (e
    1.0
    (let ((e
           (let ((x_n4
                  (-
                   (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
                   (* (/ 0.3 a44) x3))))
             (- x_n4 x4))))
      (fabs e)))
   (x1
    0.0
    (let ((x_n1
           (+
            (- (- (/ b1 a11) (* (/ 0.1 a11) x2)) (* (/ 0.2 a11) x3))
            (* (/ 0.3 a11) x4))))
      x_n1))
   (x2
    0.0
    (let ((x_n2
           (-
            (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
            (* (/ 0.2 a22) x4))))
      x_n2))
   (x3
    0.0
    (let ((x_n3
           (-
            (+ (- (/ b3 a33) (* (/ 0.2 a33) x1)) (* (/ 0.3 a33) x2))
            (* (/ 0.1 a33) x4))))
      x_n3))
   (x4
    0.0
    (let ((x_n4
           (-
            (- (+ (/ b4 a44) (* (/ 0.1 a44) x1)) (* (/ 0.2 a44) x2))
            (* (/ 0.3 a44) x3))))
      x_n4)))
  e))

(FPCore
 (x0)
 :name
 "Newton-Raphson's Method"
 :description
 "Find the zeros of a function `f = (x - 2)**5`.\nInputs: Initial guess `x0`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (< 0 x0 3)
 :example
 ((x0 0.0))
 (while
  (let ((eps 0.0005)) (and (> e eps) (< i 100000)))
  ((e
    1.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      (fabs (- x x_n))))
   (x
    0.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      x_n))
   (i 0.0 (+ i 1.0)))
  i))

(FPCore
 (x0)
 :name
 "Newton-Raphson's Method"
 :description
 "Find the zeros of a function `f = (x - 2)**5`.\nInputs: Initial guess `x0`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (< 0 x0 3)
 :example
 ((x0 0.0))
 (while
  (let ((eps 0.0005)) (and (> e eps) (< i 100000)))
  ((e
    1.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      (fabs (- x x_n))))
   (x
    0.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      x_n))
   (i 0.0 (+ i 1.0)))
  x))

(FPCore
 (x0)
 :name
 "Newton-Raphson's Method"
 :description
 "Find the zeros of a function `f = (x - 2)**5`.\nInputs: Initial guess `x0`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (< 0 x0 3)
 :example
 ((x0 0.0))
 (while
  (let ((eps 0.0005)) (and (> e eps) (< i 100000)))
  ((x_n
    0.0
    (let ((ff
           (+
            (-
             (+
              (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
              (* (* 120.0 x) x))
             (* 160.0 x))
            80.0))
          (f
           (-
            (+
             (-
              (+
               (- (* (* (* (* x x) x) x) x) (* (* (* (* 10.0 x) x) x) x))
               (* (* (* 40.0 x) x) x))
              (* (* 80.0 x) x))
             (* 80.0 x))
            32.0)))
      (- x (/ f ff))))
   (e
    1.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      (fabs (- x x_n))))
   (x
    0.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      x_n))
   (i 0.0 (+ i 1.0)))
  x_n))

(FPCore
 (x0)
 :name
 "Newton-Raphson's Method"
 :description
 "Find the zeros of a function `f = (x - 2)**5`.\nInputs: Initial guess `x0`"
 :cite
 (atkinson-1989)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (< 0 x0 3)
 :example
 ((x0 0.0))
 (while
  (let ((eps 0.0005)) (and (> e eps) (< i 100000)))
  ((e
    1.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      (fabs (- x x_n))))
   (x
    0.0
    (let ((x_n
           (let ((ff
                  (+
                   (-
                    (+
                     (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x))
                     (* (* 120.0 x) x))
                    (* 160.0 x))
                   80.0))
                 (f
                  (-
                   (+
                    (-
                     (+
                      (-
                       (* (* (* (* x x) x) x) x)
                       (* (* (* (* 10.0 x) x) x) x))
                      (* (* (* 40.0 x) x) x))
                     (* (* 80.0 x) x))
                    (* 80.0 x))
                   32.0)))
             (- x (/ f ff)))))
      x_n))
   (i 0.0 (+ i 1.0)))
  e))

(FPCore
 (a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 a41 a42 a43 a44 v1 v2 v3 v4)
 :name
 "Eigenvalue Computation"
 :description
 "Compute the largest eigenvalue of a matrix and return its vector.\nInputs: Matrix `aij`; initial guess `vi` with one nonzero element"
 :cite
 (golub-vanloan-1996)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (<
  150
  (-
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a33) a44) (* (* (* a12 a23) a34) a41))
             (* (* (* a13 a24) a31) a42))
            (* (* (* a14 a21) a32) a43))
           (* (* (* a11 a23) a34) a42))
          (* (* (* a12 a21) a33) a44))
         (* (* (* a13 a21) a32) a44))
        (* (* (* a14 a22) a33) a41))
       (* (* (* a11 a24) a32) a43))
      (* (* (* a12 a24) a31) a43))
     (* (* (* a13 a22) a34) a41))
    (* (* (* a14 a23) a31) a42))
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a34) a43) (* (* (* a12 a23) a31) a44))
             (* (* (* a13 a24) a32) a41))
            (* (* (* a14 a21) a33) a42))
           (* (* (* a11 a23) a32) a44))
          (* (* (* a12 a21) a34) a43))
         (* (* (* a13 a21) a34) a42))
        (* (* (* a14 a22) a31) a43))
       (* (* (* a11 a24) a33) a42))
      (* (* (* a12 a24) a33) a41))
     (* (* (* a13 a22) a31) a44))
    (* (* (* a14 a23) a32) a41)))
  200)
 :example
 ((a11 150.0)
  (a12 0.01)
  (a13 0.01)
  (a14 0.01)
  (a21 0.01)
  (a22 150.0)
  (a23 0.01)
  (a24 0.01)
  (a31 0.01)
  (a32 0.01)
  (a33 150.0)
  (a34 0.01)
  (a41 0.01)
  (a42 0.01)
  (a43 0.01)
  (a44 150.0)
  (v1 0.0)
  (v2 0.0)
  (v3 0.0)
  (v4 1.0))
 (while
  (let ((eps 0.0005)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (v1
    v1
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
      (/ vx vw)))
   (v2
    v2
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vy (+ (+ (+ (* a21 v1) (* a22 v2)) (* a23 v3)) (* a24 v4))))
      (/ vy vw)))
   (v3
    v3
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vz (+ (+ (+ (* a31 v1) (* a32 v2)) (* a33 v3)) (* a34 v4))))
      (/ vz vw)))
   (v4 v4 1.0)
   (e
    1.0
    (let ((v1
           (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
                 (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
             (/ vx vw))))
      (fabs (- 1.0 v1)))))
  i))

(FPCore
 (a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 a41 a42 a43 a44 v1 v2 v3 v4)
 :name
 "Eigenvalue Computation"
 :description
 "Compute the largest eigenvalue of a matrix and return its vector.\nInputs: Matrix `aij`; initial guess `vi` with one nonzero element"
 :cite
 (golub-vanloan-1996)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (<
  150
  (-
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a33) a44) (* (* (* a12 a23) a34) a41))
             (* (* (* a13 a24) a31) a42))
            (* (* (* a14 a21) a32) a43))
           (* (* (* a11 a23) a34) a42))
          (* (* (* a12 a21) a33) a44))
         (* (* (* a13 a21) a32) a44))
        (* (* (* a14 a22) a33) a41))
       (* (* (* a11 a24) a32) a43))
      (* (* (* a12 a24) a31) a43))
     (* (* (* a13 a22) a34) a41))
    (* (* (* a14 a23) a31) a42))
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a34) a43) (* (* (* a12 a23) a31) a44))
             (* (* (* a13 a24) a32) a41))
            (* (* (* a14 a21) a33) a42))
           (* (* (* a11 a23) a32) a44))
          (* (* (* a12 a21) a34) a43))
         (* (* (* a13 a21) a34) a42))
        (* (* (* a14 a22) a31) a43))
       (* (* (* a11 a24) a33) a42))
      (* (* (* a12 a24) a33) a41))
     (* (* (* a13 a22) a31) a44))
    (* (* (* a14 a23) a32) a41)))
  200)
 :example
 ((a11 150.0)
  (a12 0.01)
  (a13 0.01)
  (a14 0.01)
  (a21 0.01)
  (a22 150.0)
  (a23 0.01)
  (a24 0.01)
  (a31 0.01)
  (a32 0.01)
  (a33 150.0)
  (a34 0.01)
  (a41 0.01)
  (a42 0.01)
  (a43 0.01)
  (a44 150.0)
  (v1 0.0)
  (v2 0.0)
  (v3 0.0)
  (v4 1.0))
 (while
  (let ((eps 0.0005)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (v1
    v1
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
      (/ vx vw)))
   (v2
    v2
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vy (+ (+ (+ (* a21 v1) (* a22 v2)) (* a23 v3)) (* a24 v4))))
      (/ vy vw)))
   (v3
    v3
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vz (+ (+ (+ (* a31 v1) (* a32 v2)) (* a33 v3)) (* a34 v4))))
      (/ vz vw)))
   (v4 v4 1.0)
   (e
    1.0
    (let ((v1
           (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
                 (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
             (/ vx vw))))
      (fabs (- 1.0 v1)))))
  v1))

(FPCore
 (a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 a41 a42 a43 a44 v1 v2 v3 v4)
 :name
 "Eigenvalue Computation"
 :description
 "Compute the largest eigenvalue of a matrix and return its vector.\nInputs: Matrix `aij`; initial guess `vi` with one nonzero element"
 :cite
 (golub-vanloan-1996)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (<
  150
  (-
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a33) a44) (* (* (* a12 a23) a34) a41))
             (* (* (* a13 a24) a31) a42))
            (* (* (* a14 a21) a32) a43))
           (* (* (* a11 a23) a34) a42))
          (* (* (* a12 a21) a33) a44))
         (* (* (* a13 a21) a32) a44))
        (* (* (* a14 a22) a33) a41))
       (* (* (* a11 a24) a32) a43))
      (* (* (* a12 a24) a31) a43))
     (* (* (* a13 a22) a34) a41))
    (* (* (* a14 a23) a31) a42))
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a34) a43) (* (* (* a12 a23) a31) a44))
             (* (* (* a13 a24) a32) a41))
            (* (* (* a14 a21) a33) a42))
           (* (* (* a11 a23) a32) a44))
          (* (* (* a12 a21) a34) a43))
         (* (* (* a13 a21) a34) a42))
        (* (* (* a14 a22) a31) a43))
       (* (* (* a11 a24) a33) a42))
      (* (* (* a12 a24) a33) a41))
     (* (* (* a13 a22) a31) a44))
    (* (* (* a14 a23) a32) a41)))
  200)
 :example
 ((a11 150.0)
  (a12 0.01)
  (a13 0.01)
  (a14 0.01)
  (a21 0.01)
  (a22 150.0)
  (a23 0.01)
  (a24 0.01)
  (a31 0.01)
  (a32 0.01)
  (a33 150.0)
  (a34 0.01)
  (a41 0.01)
  (a42 0.01)
  (a43 0.01)
  (a44 150.0)
  (v1 0.0)
  (v2 0.0)
  (v3 0.0)
  (v4 1.0))
 (while
  (let ((eps 0.0005)) (> e eps))
  ((vz 0.0 (+ (+ (+ (* a31 v1) (* a32 v2)) (* a33 v3)) (* a34 v4)))
   (i 0.0 (+ i 1.0))
   (v1
    v1
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
      (/ vx vw)))
   (v2
    v2
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vy (+ (+ (+ (* a21 v1) (* a22 v2)) (* a23 v3)) (* a24 v4))))
      (/ vy vw)))
   (v3
    v3
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vz (+ (+ (+ (* a31 v1) (* a32 v2)) (* a33 v3)) (* a34 v4))))
      (/ vz vw)))
   (v4 v4 1.0)
   (e
    1.0
    (let ((v1
           (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
                 (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
             (/ vx vw))))
      (fabs (- 1.0 v1)))))
  vz))

(FPCore
 (a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 a41 a42 a43 a44 v1 v2 v3 v4)
 :name
 "Eigenvalue Computation"
 :description
 "Compute the largest eigenvalue of a matrix and return its vector.\nInputs: Matrix `aij`; initial guess `vi` with one nonzero element"
 :cite
 (golub-vanloan-1996)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (<
  150
  (-
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a33) a44) (* (* (* a12 a23) a34) a41))
             (* (* (* a13 a24) a31) a42))
            (* (* (* a14 a21) a32) a43))
           (* (* (* a11 a23) a34) a42))
          (* (* (* a12 a21) a33) a44))
         (* (* (* a13 a21) a32) a44))
        (* (* (* a14 a22) a33) a41))
       (* (* (* a11 a24) a32) a43))
      (* (* (* a12 a24) a31) a43))
     (* (* (* a13 a22) a34) a41))
    (* (* (* a14 a23) a31) a42))
   (+
    (+
     (+
      (+
       (+
        (+
         (+
          (+
           (+
            (+
             (+ (* (* (* a11 a22) a34) a43) (* (* (* a12 a23) a31) a44))
             (* (* (* a13 a24) a32) a41))
            (* (* (* a14 a21) a33) a42))
           (* (* (* a11 a23) a32) a44))
          (* (* (* a12 a21) a34) a43))
         (* (* (* a13 a21) a34) a42))
        (* (* (* a14 a22) a31) a43))
       (* (* (* a11 a24) a33) a42))
      (* (* (* a12 a24) a33) a41))
     (* (* (* a13 a22) a31) a44))
    (* (* (* a14 a23) a32) a41)))
  200)
 :example
 ((a11 150.0)
  (a12 0.01)
  (a13 0.01)
  (a14 0.01)
  (a21 0.01)
  (a22 150.0)
  (a23 0.01)
  (a24 0.01)
  (a31 0.01)
  (a32 0.01)
  (a33 150.0)
  (a34 0.01)
  (a41 0.01)
  (a42 0.01)
  (a43 0.01)
  (a44 150.0)
  (v1 0.0)
  (v2 0.0)
  (v3 0.0)
  (v4 1.0))
 (while
  (let ((eps 0.0005)) (> e eps))
  ((i 0.0 (+ i 1.0))
   (v1
    v1
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
      (/ vx vw)))
   (v2
    v2
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vy (+ (+ (+ (* a21 v1) (* a22 v2)) (* a23 v3)) (* a24 v4))))
      (/ vy vw)))
   (v3
    v3
    (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
          (vz (+ (+ (+ (* a31 v1) (* a32 v2)) (* a33 v3)) (* a34 v4))))
      (/ vz vw)))
   (v4 v4 1.0)
   (e
    1.0
    (let ((v1
           (let ((vw (+ (+ (+ (* a41 v1) (* a42 v2)) (* a43 v3)) (* a44 v4)))
                 (vx (+ (+ (+ (* a11 v1) (* a12 v2)) (* a13 v3)) (* a14 v4))))
             (/ vx vw))))
      (fabs (- 1.0 v1)))))
  e))

(FPCore
 (Q11 Q12 Q13 Q21 Q22 Q23 Q31 Q32 Q33)
 :name
 "Iterative Gram-Schmidt Method"
 :description
 "Orthogonalize a set of non-zero vectors in a Euclidian or Hermitian space.\nInputs: Vectors `Qij`"
 :cite
 (abdelmalek-bit71 golub-vanloan-1996 hernandez-roman-tomas-vidal-tr07)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 1.0 Q11 (/ 1 7)) (< 1 Q22 (/ 1 25)))
 :example
 ((Q11 (/ 1 63))
  (Q12 0)
  (Q13 0)
  (Q21 0)
  (Q22 (/ 1 225))
  (Q23 0)
  (Q31 (/ 1 2592))
  (Q32 (/ 1 2601))
  (Q33 (/ 1 2583)))
 (while
  (let ((eps 5e-06)) (> e eps))
  ((qj1
    Q31
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3)))))
   (qj2
    Q32
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
   (qj3
    Q33
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
   (r1 0.0 (let ((h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))) (+ r1 h1)))
   (r2 0.0 (let ((h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))) (+ r2 h2)))
   (r3 0.0 (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))) (+ r3 h3)))
   (e
    10.0
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      (fabs (- 1.0 (/ rjj rold)))))
   (i 1.0 (+ i 1.0))
   (rold
    (let ((r
           (let ((qj3 Q33) (qj2 Q32) (qj1 Q31))
             (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
      (sqrt r))
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      rjj)))
  i))

(FPCore
 (Q11 Q12 Q13 Q21 Q22 Q23 Q31 Q32 Q33)
 :name
 "Iterative Gram-Schmidt Method"
 :description
 "Orthogonalize a set of non-zero vectors in a Euclidian or Hermitian space.\nInputs: Vectors `Qij`"
 :cite
 (abdelmalek-bit71 golub-vanloan-1996 hernandez-roman-tomas-vidal-tr07)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 1.0 Q11 (/ 1 7)) (< 1 Q22 (/ 1 25)))
 :example
 ((Q11 (/ 1 63))
  (Q12 0)
  (Q13 0)
  (Q21 0)
  (Q22 (/ 1 225))
  (Q23 0)
  (Q31 (/ 1 2592))
  (Q32 (/ 1 2601))
  (Q33 (/ 1 2583)))
 (while
  (let ((eps 5e-06)) (> e eps))
  ((qj1
    Q31
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3)))))
   (qj2
    Q32
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
   (qj3
    Q33
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
   (r1 0.0 (let ((h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))) (+ r1 h1)))
   (r2 0.0 (let ((h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))) (+ r2 h2)))
   (r3 0.0 (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))) (+ r3 h3)))
   (e
    10.0
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      (fabs (- 1.0 (/ rjj rold)))))
   (i 1.0 (+ i 1.0))
   (rold
    (let ((r
           (let ((qj3 Q33) (qj2 Q32) (qj1 Q31))
             (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
      (sqrt r))
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      rjj)))
  qj1))

(FPCore
 (Q11 Q12 Q13 Q21 Q22 Q23 Q31 Q32 Q33)
 :name
 "Iterative Gram-Schmidt Method"
 :description
 "Orthogonalize a set of non-zero vectors in a Euclidian or Hermitian space.\nInputs: Vectors `Qij`"
 :cite
 (abdelmalek-bit71 golub-vanloan-1996 hernandez-roman-tomas-vidal-tr07)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 1.0 Q11 (/ 1 7)) (< 1 Q22 (/ 1 25)))
 :example
 ((Q11 (/ 1 63))
  (Q12 0)
  (Q13 0)
  (Q21 0)
  (Q22 (/ 1 225))
  (Q23 0)
  (Q31 (/ 1 2592))
  (Q32 (/ 1 2601))
  (Q33 (/ 1 2583)))
 (while
  (let ((eps 5e-06)) (> e eps))
  ((qj1
    Q31
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3)))))
   (qj2
    Q32
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
   (qj3
    Q33
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
   (r1 0.0 (let ((h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))) (+ r1 h1)))
   (r2 0.0 (let ((h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))) (+ r2 h2)))
   (r3 0.0 (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))) (+ r3 h3)))
   (e
    10.0
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      (fabs (- 1.0 (/ rjj rold)))))
   (i 1.0 (+ i 1.0))
   (rold
    (let ((r
           (let ((qj3 Q33) (qj2 Q32) (qj1 Q31))
             (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
      (sqrt r))
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      rjj)))
  qj2))

(FPCore
 (Q11 Q12 Q13 Q21 Q22 Q23 Q31 Q32 Q33)
 :name
 "Iterative Gram-Schmidt Method"
 :description
 "Orthogonalize a set of non-zero vectors in a Euclidian or Hermitian space.\nInputs: Vectors `Qij`"
 :cite
 (abdelmalek-bit71 golub-vanloan-1996 hernandez-roman-tomas-vidal-tr07)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 1.0 Q11 (/ 1 7)) (< 1 Q22 (/ 1 25)))
 :example
 ((Q11 (/ 1 63))
  (Q12 0)
  (Q13 0)
  (Q21 0)
  (Q22 (/ 1 225))
  (Q23 0)
  (Q31 (/ 1 2592))
  (Q32 (/ 1 2601))
  (Q33 (/ 1 2583)))
 (while
  (let ((eps 5e-06)) (> e eps))
  ((qj1
    Q31
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3)))))
   (qj2
    Q32
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
   (qj3
    Q33
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
   (r1 0.0 (let ((h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))) (+ r1 h1)))
   (r2 0.0 (let ((h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))) (+ r2 h2)))
   (r3 0.0 (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))) (+ r3 h3)))
   (e
    10.0
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      (fabs (- 1.0 (/ rjj rold)))))
   (i 1.0 (+ i 1.0))
   (rold
    (let ((r
           (let ((qj3 Q33) (qj2 Q32) (qj1 Q31))
             (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
      (sqrt r))
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      rjj)))
  qj3))

(FPCore
 (Q11 Q12 Q13 Q21 Q22 Q23 Q31 Q32 Q33)
 :name
 "Iterative Gram-Schmidt Method"
 :description
 "Orthogonalize a set of non-zero vectors in a Euclidian or Hermitian space.\nInputs: Vectors `Qij`"
 :cite
 (abdelmalek-bit71 golub-vanloan-1996 hernandez-roman-tomas-vidal-tr07)
 :fpbench-domain
 mathematics
 :precision
 binary32
 :pre
 (and (< 1.0 Q11 (/ 1 7)) (< 1 Q22 (/ 1 25)))
 :example
 ((Q11 (/ 1 63))
  (Q12 0)
  (Q13 0)
  (Q21 0)
  (Q22 (/ 1 225))
  (Q23 0)
  (Q31 (/ 1 2592))
  (Q32 (/ 1 2601))
  (Q33 (/ 1 2583)))
 (while
  (let ((eps 5e-06)) (> e eps))
  ((qj1
    Q31
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3)))))
   (qj2
    Q32
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
   (qj3
    Q33
    (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
          (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
          (h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
      (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
   (r1 0.0 (let ((h1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))) (+ r1 h1)))
   (r2 0.0 (let ((h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))) (+ r2 h2)))
   (r3 0.0 (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))) (+ r3 h3)))
   (e
    10.0
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      (fabs (- 1.0 (/ rjj rold)))))
   (i 1.0 (+ i 1.0))
   (rold
    (let ((r
           (let ((qj3 Q33) (qj2 Q32) (qj1 Q31))
             (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
      (sqrt r))
    (let ((rjj
           (let ((r
                  (let ((qj3
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj3 (+ (+ (* Q31 h1) (* Q32 h2)) (* Q33 h3)))))
                        (qj2
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj2 (+ (+ (* Q21 h1) (* Q22 h2)) (* Q23 h3)))))
                        (qj1
                         (let ((h3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))
                               (h2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))
                               (h1
                                (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3))))
                           (- qj1 (+ (+ (* Q11 h1) (* Q12 h2)) (* Q13 h3))))))
                    (+ (+ (* qj1 qj1) (* qj2 qj2)) (* qj3 qj3)))))
             (sqrt r))))
      rjj)))
  e))

