;; -*- mode: scheme -*-

(lambda ([kp 9.4514] [ki 0.69006] [kd 2.8454] [dt 0.2])
  :name "PID"
  (while (< t 100.0)
    ([t 0.0 (+ t dt)]
     [i 0.0 (+ i (* (* ki dt) (- c m)))]
     [m -5.0 (+ m (* 0.01 (+ (+ (* kp (- c m)) (+ i (* (* ki dt) (- c m)))) (* (* kd (/ 1 dt)) (- (- c m) e)))))]
     [e 0.0 (- c m)])
    m))

(lambda ([c 12.34] [sr* 0.0785398163397] [sl* 0.0525398163397] [theta* -0.985] [inv_l 0.1])
  :name "Odometry"
  (while (< t 1000)
    ;; XXX: Inlining changes the behavior around function calls; cause unknown.
    ([t 0 (+ t 1)]
     [j 0 (if (>= j 50) 0.0 (+ j 1))]
     [sr sr* (if (>= j 50) sl sr)]
     [sl sl* (if (>= j 50) sr sl)]
     [theta theta* (+ theta (* (- (* c sr) (* c sl)) inv_l))]
     ;; XXX: Changed the inline sin/cos routine to an accurate routine
     [x 0 (+ x (* (* (+ (* c sl) (* c sr)) 0.5)
                  (cos (+ theta (* (* (- (* c sr) (* c sl)) inv_l) 0.5)))))]
     [y 0 (+ y (* (* (+ (* c sl) (* c sr)) 0.5)
                  (sin (+ theta (* (* (- (* c sr) (* c sl)) inv_l) 0.5)))))])
    ;; XXX: The original code produces x and y separately
    (+ x y)))

(lambda ([eps 0.05] [y_n* 10.1] [c 100.1] [k 1.2] [h 0.1])
  :name "Runge-Kutta 4"
  (while (> e eps)
    ([t 0.0 (+ t 0.1)]
     [i 0.0 (+ i 1.0)]
     [y_n y_n* (+ y_n (* (* (/ 1 6) h)
                         (+ (+ (+ (* (* k (- c y_n)) (- c y_n))
                                  (* 2.0 (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                            (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))
                               (* 2.0 (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                                                      (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))))
                                         (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n)))))) (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))))))
                            (* (* k (- c (+ y_n (* h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                                                                     (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))))
                                                        (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                                                                (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))))))))
                               (- c (+ y_n (* h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                                                                (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))))))
                                                   (- c (+ y_n (* 0.5 h (* (* k (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n))))))
                                                                           (- c (+ y_n (* 0.5 h (* (* k (- c y_n)) (- c y_n)))))))))))))))))]
     [e 1.0 (- e eps)])
    (abs e)))

(lambda ((x0 0.0) (eps 0.005))
  :name "Newton-Raphson's Method"
  (while (and (> e eps) (< i 100000))
    ([x 0.0 (- x
               (/ (- (+ (- (+ (- (* (* (* (* x x) x) x) x) (* (* (* (* 10.0 x) x) x) x)) (* 40.0 x x x)) (* (* 80.0 x) x)) (* 80.0 x)) 32.0)
                  (+ (- (+ (- (* (* (* (* 5.0 x) x) x) x) (* (* (* 40.0 x) x) x)) (* 120.0 x x)) (* 160.0 x)) 80.0)))]
    [i 0.0 (+ i 1.0)])
   (+ (+ (+ i x) x_n) e)))

(lambda ((b3 0.25) (b1 0.5) (a44 0.601) (a33 0.6006) (a22 0.62) (a11 0.61) (eps 1e-17))
  :name "Jacobi's Method"
  (while (> e eps)
    ([i 0.0 (+ i 1.0)]
     [x1 0.0 (+ (- (- (/ b1 a11) (* (/ 0.1 a11) x2)) (* (/ 0.2 a11) x3))
                (* (/ 0.3 a11) x4))]
     [x2 0.0 (- (+ (- (/ b2 a22) (* (/ 0.3 a22) x1)) (* (/ 0.1 a22) x3))
                (* (/ 0.2 a22) x4))]
     [x3 0.0 (- (+ (- (/ b3 a33) (* (/ 0.2 a33) x1)) (* (/ 0.3 a33) x2))
                (* (/ 0.1 a33) x4))])
    (+ (+ (+ i x_n2) x2) e)))

;; Eigenvalue Computation

(lambda ((yd 5.0) (Dc -1280.0) (Cc1 0.0) (Cc0 564.48) (Bc1 0.0) (Bc0 1.0)
         (Ac11 1.0) (Ac10 0.01) (Ac01 -0.05) (Ac00 0.499) (y 2.5) (eps 0.01))
  :name "Lead-lag System"
  (while (> e eps)
    ([xc0 0.0 (+ (* Ac00 xc0) (+ (* Ac01 xc1) (* Bc0 (if (< 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))) 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))))))]
     [xc1 0.0 (+ (* Ac10 (+ (* Ac00 xc0) (+ (* Ac01 xc1) (* Bc0 (if (< 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))) 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))))))) (+ (* Ac11 xc1) (* Bc1 (if (< 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))) 1.0 (if (< (- y yd) -1.0) -1.0 (- y yd))))))]
     [i 0.0 (+ i 1.0)])
    xc1))

(lambda ((eps 5e-06) (Q23 0.0) (Q21 0.0) (Q13 0.0) (Q12 0.0))
  :name "Iterative Gram-Schmidt Method"
  (while (> e eps)
   ([qj1 (/ 1.0 2592.0)
         (- qj1 (+ (+ (* Q11 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))
                      (* Q12 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3))))
                   (* Q13 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))))]
    [qj2 (/ 1.0 2601.0)
         (- qj2 (+ (+ (* Q21 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))
                      (* Q22 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3))))
                   (* Q23 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))))]
    [qj3 (/ 1.0 2583.0)
         (- qj3 (+ (+ (* Q31 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))
                      (* Q32 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3))))
                   (* Q33 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))))]
    [r1 0.0 (+ r1 (+ (+ (* Q11 qj1) (* Q21 qj2)) (* Q31 qj3)))]
    [r2 0.0 (+ r2 (+ (+ (* Q12 qj1) (* Q22 qj2)) (* Q32 qj3)))]
    [r3 0.0 (+ r3 (+ (+ (* Q13 qj1) (* Q23 qj2)) (* Q33 qj3)))]
    [i 1.0 (+ i 1.0)])
   (+ (+ (+ (+ i qj1) qj2) qj3) e)))

;; Rocket trajectory
