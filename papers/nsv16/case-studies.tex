\documentclass[main.tex]{subfiles}
\begin{document}

\section{Benchmark Case Studies}
\label{sec:casestudies}

The \name suite includes \nbenches benchmarks
  sourced from recent papers in floating point verification,
  optimization, and accuracy improvement.
Moreover, it can be used to represent the input
  to a variety of floating point tools
  which measure error in a variety of ways.
This section discusses the benchmarks
  already included in the \name suite,
  and highlights representative examples
  from the test suites of various floating point tools.

\subsection{Benchmark Suite}

The \name suite includes \nbenches benchmarks
  sourced from recent papers in floating point verification,
  optimization, and accuracy improvement.
Of the benchmarks,
  FPBench draws 28 from the Herbie test suite~\cite{pavel15},
  9 from the Salsa test suite~\cite{fmics15},
  7 from the Rosa test suite~\cite{DarulovaK14},
  and one from the FPTaylor test suite~\cite{fptaylor-fm15}.
Together, these programs come from
  a variety of domains and applications,
  from control software to mathematical libraries
  (see Table~\ref{tbl:domains}).
The included benchmarks use the range of functionality
  available in \name (see Table~\ref{tbl:features}).

\begin{table}[hbtp]
  \begin{minipage}[t]{.45\textwidth}
    \begin{tabular}{lr}
      Name & Benchmarks \\\hline
      Basic Arithmetic & 44 \\
      Exponentials & 13 \\
      Trigonometric & 10 \\
      Comparison & 12 \\
      Conditionals & 3 \\
      Loops & 12
    \end{tabular}
    \caption{Domains from which the \name benchmarks are taken. The
      mathematical expressions are the smallest, and are largely
      drawn from \textit{Numerical Methods for Scientists and
        Engineers}~\cite{hamming-1987}.}
    \label{tbl:domains}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.45\textwidth}
    \begin{tabular}{lr}
      Domain & Benchmarks \\\hline
      Math expressions & 29 \\
      Math algorithms & 4 \\
      Physics & 3 \\
      Control & 5
    \end{tabular}
    \caption{Functions and language features used in the \name
      benchmarks. Exponential functions include logarithms, the
      exponential function, and the power function.}
    \label{tbl:features}
  \end{minipage}
\end{table}

The \name suite attempts balance on multiple dimensions.
Beyond drawing from a range of domains with varying features,
  \name also balances the need for simple benchmarks
  to prove algorithms on
  with larger, practical examples.
To achieve this balance,
  a large number of basic expressions,
  coupled with a smaller number of large test cases.
Among the larger test cases a degree of diversity is also available,
  with programs ranging
  from 2 to 13 variables mutated in the loop body.

\subsection{FPTaylor}
In the paper ``Rigorous Estimation of Floating-Point Round-off Errors
with Symbolic Taylor Expansions'', by Solovyev et al
\cite{fptaylor-fm15}, the authors build a tool which uses Taylor
series expansions and interval arithmetic to obtain sound error bounds
on programs. The simple program below is used as an example of an input
to the tool:

\begin{verbatim}
1: Variables
2:   float64 x in [1.001, 2.0],
3:   float64 y in [1.001, 2.0];
4: Definitions
5:   t rnd64= x * y;
6: // Constraints
7: //  x + y <= 2;
8: Expressions
9:   r rnd64= (t-1)/(t*t-1);
\end{verbatim}

This program is roughly representative of a small piece of code one
might use to calculate the behavior of some control software based on
sensor data, where the output of the sensor is known to be between
1.001 and 2.0.

In \core format, the program is represented as:

\begin{verbatim}
(lambda (x y)
  :name "FPTaylor example"
  :cite (solovyev-et-al-2015)
  :type double
  :pre (and (< 1.001 x) (< x 2.0) (< 1.001 y) (< y 2.0))
  (let ([t (* x y)])
    (/ (- t 1.0)  (- (* t t) 1.0))))
\end{verbatim}

The benchmark takes two inputs, ``\verb|x|'' and ``\verb|y|'', and is
given a name within the benchmark suite, ``\verb|FPTaylor example.|''
It cites the paper in which it appears, ``Rigorous Estimation of
Floating-Point Round-off Errors with Symbolic Taylor Expansion,''
through a standard .bib file included in the benchmark suite, which
the benchmark references via the handle
``\verb|solovyev-et-al-2015|.''

Since the original program specifies that the floating point numbers
used are 64-bit floats, the type is annotated as ``\verb|double|.''
Preconditions on the input are translated into a single predicate
denoted with the ``\verb|:pre|'' keyword specifier. In this case these
correspond to reasonable input ranges from the domain in which this
benchmark originates.

Finally, the program text is represented in \core an s-expression
based syntax, described in Section~\ref{sec:format}. \core faithfully
preserves important program constructs, such as variable binding and
operation ordering, while eliding details of the program that are not
relevant to it's floating point behavior, such as the particulars of
syntax.

\subsection{Rosa}
The paper ``Sound Compilation of the Reals,'' by Darulova et
al~\cite{DarulovaK14}, describes a tool Rosa which verifies sound
error bounds of numerical programs. While not represented in the
paper, the tool supports looping control flow through recursive
function calls, and has several benchmarks in it's repository which
showcase this ability. One of these is a function which computes the
sine function using Newton's method. In Scala, the original input
language, the benchmark is represented as:

\begin{verbatim}
def newton(x: Real, k: LoopCounter): Real = {
  require(-1.0 < x && x < 1.0)

  if (k < 10) {
    newton(x - (x - (x°°3)/6.0 + (x°°5)/120.0 + (x°°7)/5040.0) / 
      (1.0 - (x*x)/2.0 + (x°°4)/24.0 + (x°°6)/720.0), k++)
  } else {
    x
  }
  
} ensuring(res => -1.0 < res && res < 1.0)
\end{verbatim}

With a \verb|require| clause denoting input preconditions, and an
\verb|ensures| clause providing error bounds to be verified. In
\name, the same benchmark is represented as:

\begin{verbatim}
(lambda (x0)
  :name "Sine Newton"
  :cite (darulova-kuncak-2014)
  :pre (< (abs x0) 1.)
  (while (< i 10)
    ([x x0 (- x (/ (+ (+ (- x (/ (expt x 3) 6.0)) 
                         (/ (expt x 5) 120.0))
                      (/ (expt x 7) 5040.0))
                   (+ (+ (- 1.0 (/ (* x x) 2.0)) 
                         (/ (expt x 4) 24.0)) 
                      (/ (expt x 6) 720.0))))]
     [i 0 (+ i 1)])
    x))
\end{verbatim}

Like the FPTaylor benchmark above, this benchmark includes the name of
the benchmark, ``\verb|Sine Newton|,'' a citation which references the
benchmark suite .bib file, and a precondition on inputs taken from a
particular domain. In addition to features showcased by the FPTaylor
benchmark, this translated Rosa benchmark showcases the while
construct, a construct in \core that represents general loops as
iterative updates of a set of variables until some condition is
falsified.

\subsection{Herbie}

In the paper ``Automatically Improving Accuracy for Floating Point
Expressions'', by Panchekha et al~\cite{pavel15}, the authors build a
tool, ``Herbie'', which heuristically improves the accuracy of
straight-line floating point expressions. \name benchmarks need not
only represent the input to floating point tools; for tools which
transform one floating point program to another, \core can also be
used to represent the output of the tool.

The quadratic formula is used to illustrate the various steps of
accuracy improvement with Herbie. The quadratic formula is a common
formula used to compute the roots of a degree two polynomial. It
appears in \textit{Numerical Methods for Scientists and Engineers}, by
Richard Hamming, in a section on rearranging computations for
numerical accuracy. It has uses in a variety of applications, from
calculating trajectories, to solving matrix equations. In mathematical
notation, the quadratic formula is written as:

\begin{equation}
  \frac{(- b) \pm \sqrt{b^2 - 4ac}}{2a}
\end{equation}

with a negative variant:

\begin{equation}
  \frac{(- b) - \sqrt{b^2 - 4ac}}{2a}
\end{equation}

After running on this program, Herbie produces the improved
expression:

\newcommand{\K}[1]{\ensuremath{\mathbf{#1}}\relax\ifmmode\:\else\fi}

\[
\begin{cases}
  \frac{4ac}{-b + \sqrt{b^2 - 4ac}}/2a & \K{if} b < 0 \\[9pt]
  \left(-b - \sqrt{b^2 - 4ac}\right)\frac1{2a} & \K{if} 0 \le b \le 10^{127} \\[5pt]
  -\frac{b}{a} + \frac{c}{b} & \K{if} 10^{127} < b
\end{cases}
\]

In \core format, the input of formula is represented as:

\begin{verbatim}
(lambda (a b c)
  :name "NMSE p42, positive"
  :cite (hamming-1987)
  :pre (and (>= (sqr b) (* 4 (* a c))) (not (= a 0)))
  (/ (+ (- b) (sqrt (- (sqr b) (* 4 (* a c))))) (* 2 a)))
\end{verbatim}

and Herbie's output can be represented:

\begin{verbatim}
(lambda (a b c)
  :name "NMSE p42, positive"
  :cite (hamming-1987)
  :pre (and (>= (sqr b) (* 4 (* a c))) (not (= a 0)))
  (if (< b 0)
      (/ (* 4 (* a c))
         (/ (+ (- b) (sqrt (- (sqr b) (* 4 (* a c)))))
            (* 2 a)))
      (if (< b 10e127)
          (* (- (- b) (- (sqr b) (* 4 (* a c)))) (/ 1 (* 2 a)))
          (+ (- (/ b a)) (/ c b)))))
\end{verbatim}

The benchmark in both it's forms takes three inputs, denoted
``\verb|a|'', ``\verb|b|'', and ``\verb|c|'' above. It is named
``\verb|NMSE p42, positive|'' after the book in which it appears and
its exercise number, as well as which branch it is. Like the FPTaylor
benchmark, it cites its source through a shorthand, in this case
``\verb|hamming-1987|'', which corresponds to a .bib file included
with the benchmark suite.

The benchmark also denotes a range of acceptable inputs, through
preconditions. For the quadratic formula, since it is ill defined to
take the square root of a negative number, we restrict the input to
the square root to be non-negative. Additionally, it is ill defined to
divide by zero, so we restrict the denominator of the division to be
non-zero, by restricting the input ``\verb|a|'' to be non-zero. In
contrast to the FPTaylor example above, here the preconditions arise
not from a limited input range in the problem domain, but from a
limitation on the defined-ness of the formula.

\subsection{Martel}
In the paper ``Intra-procedural Optimization of the Numerical Accuracy
of Programs,'' by Damouche et al~\cite{fmics15}, the authors build a
tool to optimize the numerical accuracy of programs. The evaluate the
tool on a suite of control and numerical algorithms, including a
widely used PID controller algorithm. This algorithm is used in
aeronautic and avionic systems for which correctness is critical. In
C, the benchmark is written as:

\begin{verbatim}
volatile double p, i, t, d, dt, invdt, m, e, eold, r; 

int pid(double m0, double kp, double ki, double kd, double c){

  t     = 0.0;
  invdt = 5.0;
  dt    = 0.2;
  m     = m0 ;
  eold  = 0.0;
  i     = 0.0;
  
  while (t < 100.0) {
       e = c - m;
       p = kp * e;
       i = i + ki * dt * e;
       d = kd * invdt * (e - eold);
       r = p + i + d;
       m = m + 0.01 * r; /* computing measure: the plant */
       eold = e;
       t = t + dt;
  }
  return m;
}
\end{verbatim}

with some inputs given fixed values. In \core format, the benchmark
is represented as represented as:

\begin{verbatim}
(lambda (m0 kp ki kd c)
  :name "PID"
  :description 
  "Keep a measure at its setpoint using a PID controller."
  :inputs 
  "Initial measure `m0`; gains `kp`, `ki`, `kd`; setpoint `c`"
  :cite (damouche-martel-chapoutot-nsv14)
  :type double
  :pre (and (< -10.0 m0) (< m0 10.0) (< -10.0 c) (< c 10.0))
  (while
   (< t 100.0)
   ([i 0.0 (+ i (* (* ki 0.2) (- c m)))]
    [m m0
     (+ m (* 0.01 (+ (+ (* kp (- c m))
                        (+ i (* (* ki 0.2) (- c m))))
                     (* (* kd (/ 1 0.2))
                        (- (- c m) eold)))))]
    [eold 0.0 (- c m)]
    [t 0.0 (+ t 0.2)])
   m))
\end{verbatim}

This benchmark incorporates many of the features of \core previously
described: it is named (``\verb|PID|''), it has a citation
(``\verb|damouche-martel-chapoutot-nsv14|''), it specifies the type of
floating point number used (``\verb|double|''), and it has
domain-based restrictions on it's input. This benchmark also showcases
a few more features of \core: since the benchmark source included
information describing the benchmark and it's inputs, we include this
information in the \name benchmark. The ``\verb|:description|'' tag
marks a description of the benchmark as a whole, while the
``\verb|:inputs|'' tag marks descriptions of the inputs to a
program. These descriptions can contain information about the
distribution of inputs, the situation in which the benchmark is used,
and any other information which might be useful to tool writers.
\end{document}
