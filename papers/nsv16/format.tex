\documentclass[main.tex]{subfiles}
\begin{document}

\section{Benchmark Format}
\label{sec:format}

To support broad usage,
  a common floating point benchmark format must be
  easy to parse,
  have simple and clear semantics,
  support floating-point details, and
  provide sufficient expressiveness for diverse application domains.
\name satisfies these requirements
  with the \core format,
  a simplified expression-based language
  for floating-point operations
  with features for specifying input ranges,
  error measures, target accuracy, floating-point
  precision to use, etc.
A common benchmark format
  must also be easy to translate to and from
  popular industrial languages like C, C++, Matlab, and Fortran.
\name satisfied this requirement with
  the extended \surface format,
  a simplified imperative language for floating-point operations
  which can be automatically compiled to \core.
Since \surface can be compiled to \core,
  the combination of the two languages
  allows achieving both simplicity of analysis
  and simplicity of translation.


%% The \name format must be easy to parse
%%   and have simple, easily-modeled semantics
%%   that allow the details of floating-point arithmetic
%%   to come to the fore.
%% These goals are fulfilled by the \core format,
%%   a simplified expression-based language for floating-point operations
%%   inspired by the \smtlib format used in the SMT competition.
%% \name is also intended to grow
%%   by incorporating code extracted
%%   from numerical systems used in science, industry, and government;
%%   so, it must be easy to translate C, C++, Matlab, and Fortran
%%   into \name's format,
%%   while glossing over language differences.
%% These goals are fulfilled by the \surface format,
%%   a simplified imperative language for floating-point operations
%%   which can be automatically compiled to \core.
%% Users of \name can analyze benchmarks either in \core,
%%   if they want to avoid the complexities of imperative programs,
%%   or in \surface,
%%   if the additional information latent in imperative control flow
%%   is valuable to the analysis.
%% Since \surface can be compiled to \core,
%%   the combination of the two languages
%%   allows achieving both simplicity of analysis
%%   and simplicity of translation.

\subsection{\core}

\core is an S-expression format featuring
  mathematical functions, \C{if} statements, and \C{while} loops.
All floating-point functions
  from C11's \C{math.h} and all Fortran 2003 intrinsics
  are supported operators,
  as well as standard arithmetic operators like addition and comparison;
  likewise, all constants defined in C11's \C{math.h} are available as constants.
Since neither IEEE754 nor common C or Fortran implementations specify
  an accuracy for their mathematical functions,
  \core does not prescribe a accuracy for these values.
However, individual benchmarks can declare the accuracy
  they assume for these built-in operations which
  tools and analyzers can take into account.

%%   neither does \core specify the values of these functions.
%% We expect that most libraries implement these functions
%%   to within a few ulps of accuracy;
%%   for example, on most architectures
%%   the GNU \C{libm} gives accurate answers across most of the input range.

A \core benchmark specifies a set of inputs,
  a floating-point expression,
  and meta-data flags.
Meta-data flags include a name,
  citations, preconditions on the inputs,
  and the floating-point precision
  (\C{binary32}, \C{binary64}, etc.)
  used to evaluate that benchmark.
The full \core syntax is as follows:

\begin{grammar}
\small
<\core> ::= ( `lambda' ( <identifier>* ) <property>* <expression> )

<expression> ::= <number> | <constant> | <identifier>
\alt ( <operation> <expression>* )
\alt ( `if' <expression> <expression> <expression> )
\alt ( `while' <expression> ( <loopvar>* ) <expression> )
\alt ( `let' ( <binding>* ) <expression> )

<loopvar> ::= [ <identifier> <expression> <expression> ]

<constant> ::= `E' | `LOG2E' | `LOG10E' | `LN2' | `LN10' | `PI' | $\dotsb$

<operation> ::= `+' | `*' | `<' | $\dotsb$ | `abs' | `acos' | `and' | `asin' | $\dotsb$

<property> ::= <propname> <propval>

<propname> ::= `:name' | `:cite' | `:pre' | `:type' | $\dotsb$

<propval> ::= <expression> | <string> | ( <identifier>* ) | <identifier>

<binding> ::= [ <identifier> <expression> ]
\end{grammar}

In this grammar, parentheses and braces are literals
  (since the language is S-expression based).
Note that by convention,
  we use ``\C{;}'' to indicate
  that the remainder of a line is a comment.
The semantics of these programs is ordinary function evaluation,
  with \C{let} bindings evaluated simultaneously
  and \C{while} loops evaluated
  by simultaneously updating the loop variables
  until the condition is true,
  and then evaluating the return value:

\begin{mathpar}
\small
\inferrule{
  H : x_i^0 \evalto v_i \\
  H[x_i \mapsto v_i]_i: c \evalto \top \\
  H[x_i \mapsto v_i]_i: e_i \evalto x_i' \\
  H: (\C{while}\quad c\quad ([x_i\quad x_i'\quad e_i]_i)\quad y) \evalto v
}{
  H: (\C{while}\quad c\quad ([x_i\quad x_i^0\quad e_i]_i)\quad y) \evalto v
}

\inferrule{
  H : x_i^0 \evalto v_i \\
  H[x_i \mapsto v_i]_i : c \evalto \bot \\
  H[x_i \mapsto v_i]_i : y \evalto v
}{
  H: (\C{while}\quad c\quad ([x_i\quad x_i^0\quad e_i]_i)\quad y) \evalto v
}
\end{mathpar}

The list of properties is used to record additional information
  about each benchmark.
Existing benchmarks are annotated with a \C{:name},
  a \C{:description} of the benchmark and its inputs,
  the floating-point \C{:type} (either \C{float} or \C{double}),
  a precondition \C{:pre}, and a citation \C{:cite}.
All \name tools ignore unknown attributes,
  so they represent an easy way to record additional benchmark information.
We recommend that properties specific to a single tool
  be prefixed with the name of the tool.

\subsection{\surface}

While \core is a functional language
  with a minimal set of features
  for representing floating-point formats,
  \surface includes common imperative features
  like variable assignments,
  multiple return values,
  and multi-way \C{if} statements.
More complex features,
  such as arrays, pointers, and records,
  are left to future language extensions.
In our experience,
  translating C, Fortran, and Matlab to \surface is relatively easy.
\surface syntax uses \core for expressions;
  however, analyzing \surface allows tracking intermediate variables
  and control flow at a finer scale than that allowed by \core.
The additional syntactic constructs of \surface are:

\begin{grammar}
<\surface> ::= ( `function' ( <identifier>* ) <property>* <statement>* <return> )

<return> ::= ( `output' <expression>* )

<statement> ::= [ `=' <identifier> <expression> ]
\alt ( `if' <ifbranch>* )
\alt ( `while' <expression> <statement>* )

<ifbranch> ::= [ <expression> <statement>* ]
\alt [ `else' <statement>* ]
\end{grammar}

Like in \core, each \surface benchmark
  includes free parameters and properties;
  as an imperative language,
  it includes a list of program statements
  and multiple return values
  instead of a single body expression.
Assignments and while loops behave in the usual way.
An \C{if} statement defines a many-way branch;
  any \C{else} branch must be the last branch in its \C{if}.
The \C{output} statement returns several values and appears
  at the end of a function.
Each expression in a \surface program is a \core expression,
  making it easy to extend an analysis on \core benchmarks
  to analyzing \surface programs instead,
  and ensuring that the same set of operations and constants
  are supported.

The \surface to \core compiler
  translates \surface functions to \core benchmarks
  while retaining all properties and keeping the same set of free parameters.
It inlines assignments, convert the imperative bodies of \surface loops
  to the simultaneous-assignment loops of \core,
  replaces many-way \C{if} statements with nested \C{if}s,
  and rewrites variary mathematical operators like \C{+} and \C{*}
  to a left-associative application of binary operators.

\end{document}
