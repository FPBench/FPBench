\documentclass[main.tex]{subfiles}
\begin{document}

\section{Benchmark Format}
\label{sec:format}

The \name format must be easy to parse
  and have simple, easily-modeled semantics
  that allow the details of floating point arithmetic
  to come to the fore.
These goals are fulfilled by the \core format,
  a simplified expression-based language for floating point operations
  inspired by the \smtlib format used in the SMT competition.
\name is also intended to grow
  by incorporating code extracted
  from numerical systems used in science, industry, and government;
  so, it must be easy to translate C, C++, Matlab, and Fortran
  into \name's format,
  while glossing over language differences.
These goals are fulfilled by the \surface format,
  a simplified imperative language for floating point operations
  which can be automatically compiled to \core.
Users of \name can analyze benchmarks either in \core,
  if they want to avoid the complexities of imperative programs,
  or in \surface,
  if the additional information latent in imperative control flow
  is valuable to the analysis.
Since \surface can be compiled to \core,
  the combination of the two languages
  allows achieving both simplicity of analysis
  and simplicity of translation.
  
\subsection{\core}

\core is an S-expression format featuring
  mathematical functions, \C{if} statements, and \C{while} loops.
All floating-point functions
  from C11's \C{math.h} and all Fortran 2003 intrinsics
  are supported operators,
  as well as standard arithmetic operators like addition and comparison;
  likewise, all constants defined in C11's \C{math.h} are available as constants.
Since neither IEEE754 nor C and Fortran implementations specify
  an accuracy for their mathematical functions,
  neither does \core specify the values of these functions.
We expect that most libraries implement these functions
  to within a few ulps of accuracy;
  for example, on most architectures
  the GNU \C{libm} gives accurate answers across most of the input range.

A \core benchmark specifies a \core expression,
  a collection of free parameters,
  and properties containing meta-data about that benchmark.
Metadata flags included in \name include a name for each benchmark,
  a list of citations, preconditions for the free parameters,
  and the floating point type (\C{float} or \C{double})
  used to evaluate that benchmark.
The full \core syntax is as follows:

\begin{grammar}
<\core> ::= ( `lambda' ( <identifier>* ) <property>* <expression> )

<expression> ::= <number> | <constant> | <identifier>
\alt ( <operation> <expression>* )
\alt ( `if' <expression> <expression> <expression> )
\alt ( `while' <expression> ( <loopvar>* ) <expression> )

<loopvar> ::= [ <identifier> <expression> <expression> ]

<constant> ::= `E' | `LOG2E' | `LOG10E' | `LN2' | `LN10' | `PI' | $\dotsb$

<operation> ::= `+' | `*' | `<' | $\dotsb$ | `abs' | `acos' | `and' | `asin' | $\dotsb$

<property> ::= <propname> <propval>

<propname> ::= `:name' | `:cite' | `:pre' | `:type' | $\dotsb$

<propval> ::= <expression> | <string> | ( <identifier>* ) | <identifier>
\end{grammar}

In this grammar, parentheses and braces are literals
  (since the language is S-expression based).
The semantics of these programs is ordinary function evaluation,
  with \C{while} loops evaluated
  by simultaneously updating the loop variables
  until the condition is true,
  and then evaluating the return value:

\begin{mathpar}
\inferrule{
  H[x_i \mapsto x_i^0]: c \evalto \top \\
  H[x_i \mapsto x_i^0]: e_i \evalto x_i'
}{
  H: (\C{while}\:c\:([x_i\:x_i^0\:e_i]_i)\:y)
  \to
  H: (\C{while}\:c\:([x_i\:x_i'\:e_i]_i)\:y)
}

\inferrule{
  H[x_i \mapsto x_i^0] : c \evalto \bot \\
  H[x_i \mapsto x_i^0] : y \evalto v
}{
  H: (\C{while}\:c\:([x_i\:x_i^0\:e_i]_i)\:v)
  \evalto
  w
}
\end{mathpar}

\subsection{\surface}

While \core is a functional language
  with a minimal set of features
  for representing floating point formats,
  \surface includes common imperative features
  like variable assignments,
  multiple return values,
  and multi-way \C{if} statements.
More complex features,
  such as arrays, pointers, and records,
  are left to future language extensions.
In our experience,
  translating C, Fortran, and Matlab to \surface is relatively easy.
\surface syntax builds uses \core for expressions;
  however, analyzing \surface allows tracking intermediate variables
  and control flow at a finer scale than that allowed by \core.
The additional syntactic constructs of \surface are:

\begin{grammar}
<\surface> ::= ( `function' ( <identifier>* ) <property>* <statement>* <return> )

<return> ::= ( `output' <expression>* )

<statement> ::= [ `=' <identifier> <expression> ]
\alt ( `if' <ifbranch>* )
\alt ( `while' <expression> <statement>* )

<ifbranch> ::= [ <expression> <statement>* ]
\alt [ `else' <statement>* ]
\end{grammar}

Like in \core, each \surface benchmark
  includes free parameters and properties;
  as an imperative language,
  it includes a list of program statements
  and multiple return values
  instead of a single body expression.
Assignments and while loops behave in the usual way.
An \C{if} statement defines a many-way branch;
  any \C{else} branch must be the last branch in its \C{if}.
The \C{output} statement returns several values and appears
  at the end of a function.
Each expression in a \surface program is a \core expression,
  making it easy to extend an analysis on \core benchmarks
  to analyzing \surface programs instead,
  and ensuring that the same set of operations and constants
  are supported.

The \surface to \core compiler
  translates \surface functions to \core benchmarks
  while retaining all properties and keeping the same set of free parameters.
It inlines assignments, convert the imperative bodies of \surface loops
  to the simultaneous-assignment loops of \core,
  replaces many-way \C{if} statements with nested \C{if}s,
  and rewrites variary mathematical operators like \C{+} and \C{*}
  to a left-associative application of binary operators.

\end{document}
