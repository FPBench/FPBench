\documentclass[main.tex]{subfiles}
\begin{document}

\section{Benchmark Format}
\label{sec:format}

The \name format must be easy to parse
  and have simple, easily-modeled semantics
  that allow the details of floating point arithmetic
  to come to the fore.
These goals are fulfilled by the \core format,
  a simplified expression-based language for floating point operations
  inspired by the \smtlib format used in the SMT competition.
\name is also intended to grow
  by incorporating code extracted
  from numerical systems used in science, industry, and government;
  so, it must be easy to translate C, C++, MatLab, and Fortran
  into \name's format,
  while glossing over language differences.
These goals are fulfilled by the \surface format,
  a simplified imperative language for floating point operations
  which can be automatically compiled to \core.
Users of \name can analyze benchmarks either in \core,
  if they want to avoid the complexities of imperative programs,
  or in \surface,
  if the additional information latent in imperative control flow
  is valuable to the analysis.
  
\subsection{\core}

\core is an S-expression format featuring
  mathematical functions, \C{if} statements, and \C{while} loops.
All floating-point functions
  from C11's \C{math.h} and all Fortran 2003 intrinsics
  are supported operators,
  as well as standard arithmetic operators like addition and comparison;
  likewise, all constants defined in C11's \C{math.h} are available as constants.
Since neither IEEE754 nor C and Fortran implementations specify
  an accuracy for their mathematical functions,
  neither does \core specify the values of these functions.
We expect that most libraries implement these functions
  to within a few ulps of accuracy;
  for example, on most architectures
  the GNU \C{libm} gives accurate answers across most of the input range.

A \core benchmark specifies a \core expression,
  a collection of free parameters,
  and properties containing meta-data about that benchmark.
Metadata flags included in \name include a name for each benchmark,
  a list of citations, preconditions for the free parameters,
  and the floating point type (\C{float} or \C{double})
  used to evaluate that benchmark.
The full \core syntax is as follows:

\begin{figure}
\begin{grammar}
<benchmark> ::= ( `lambda' ( <identifier>* ) <property>* <expression> )

<expression> ::= <number> | <constant> | <identifier>
\alt ( <operation> <expression>* )
\alt ( `if' <expression> <expression> <expression> )
\alt ( `while' <expression> ( <loopvar>* ) <expression> )

<loopvar> ::= [ <identifier> <expression> <expression> ]

<constant> ::= `E' | `LOG2E' | `LOG10E' | `LN2' | `LN10' | `PI' | $\dotsb$

<operation> ::= `+' | `*' | `<' | $\dotsb$ | `abs' | `acos' | `and' | `asin' | $\dotsb$

<property> ::= <propname> <propval>

<propname> ::= `:name' | `:cite' | `:pre' | `:type' | $\dotsb$

<propval> ::= <expression> | <string> | ( <identifier>* ) | <identifier>

\end{grammar}
\caption{The grammar of the \core language. Since the language is an
  S-expression format, parentheses and braces are literal in this
  grammar.}
\label{fig:core}
\end{figure}

The semantics of these programs is ordinary function evaluation,
  with \C{while} loops evaluated
  by simultaneously updating the loop variables
  until the condition is true,
  and then evaluating the return value:

\begin{mathpar}
\inferrule{
  H[x_i \mapsto x_i^0]: c \evalto \top \\
  H[x_i \mapsto x_i^0]: e_i \evalto x_i'
}{
  H: (\C{while}\:c\:([x_i\:x_i^0\:e_i]_i)\:y)
  \to
  H: (\C{while}\:c\:([x_i\:x_i'\:e_i]_i)\:y)
}

\inferrule{
  H[x_i \mapsto x_i^0] : c \evalto \bot \\
  H[x_i \mapsto x_i^0] : y \evalto v
}{
  H: (\C{while}\:c\:([x_i\:x_i^0\:e_i]_i)\:v)
  \evalto
  w
}
\end{mathpar}

\subsection{surface}

sdkfjas;kljf

\end{document}
