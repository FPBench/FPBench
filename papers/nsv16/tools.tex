\documentclass[main.tex]{subfiles}
\begin{document}

\section{Tools}
\label{sec:tools}

\name features
  a collection of compilers and measurement tools
  that operate on its common format, \core.
These tools can be a community resource,
  increasing interoperability and code reuse.
They also make it easier to write
  new floating-point analysis and transformation tools
  by automating what are currently
  common but tedious tasks.

\paragraph{\surface to \core}
The \core format faithfully preserves important program constructs,
  such as variable binding and operation ordering,
  while abstracting away details not relevant
  to the floating-point semantics.
However, it is syntactically very different
  from some of the languages from which benchmarks might originate.
To make translation to \core from source languages
  like C, Fortran, and Matlab easier,
  \name also specifies another format,
  \surface.
\surface is syntactically similar to imperative languages,
  but is automatically translatable to \core.
\name provides a compiler from \surface to \core
  to make translation of benchmarks as easy as possible.

\paragraph{\core to C}
Since C is a common implementation language for mathematical computations,
  \name provides a \core to C compiler.
We expect this to be especially useful for tools
  that improve the accuracy of floating-point expressions
  and want to return the most accurate expressions to users.
The \core to C compiler can also be used
  to run \name benchmarks
  using the many available C analysis tools.

\paragraph{Worst-case error estimation}
\name provides a tool to give bounds on
  the worst-case absolute error of a \core program
  using an abstract interpretation based on interval analysis
  following the approach pioneered by Martel et~al.~\cite{martel-ai}.
The error analysis is fast
  and applies to loops without the need for loop invariants,
  though specialized tools such as Rosa~\cite{DarulovaK14}
  and FPTaylor~\cite{fptaylor-fm15}
  provide tighter error bounds.
For tools that improve the accuracy of floating-point computations,
  the static error analysis is a way to compare
  the original and improved computation,
  while tools that optimize programs given accuracy bounds
  can use the static analysis to derive the accuracy bounds demanded.

\paragraph{Average error estimation}
Average error is a second important metric for floating-point programs,
  and \name provides a tool to statistically approximate it.
The statistical approach is necessary to produce accurate estimates
  of average error given the current state of the art.
The average error estimate combines with worst-case error bounds
  to provide detailed information about the error behavior
  of a floating-point program.

\end{document}
